#![allow(non_snake_case)]

use web_sys::window;

use dioxus::prelude::*;
use fwm_as::{lex::Lex, tree::SyntaxTree, writer};
use fwm_as_vmgen::{FWMInfo, VMInfoBuilder};
use fwm_base::{
    opcode::OPCodeKind,
    parser,
    runner::{FWMRunner, FWMSignal},
};

use crate::components::{Codebox, Inputbox};

mod components;

const DEFAULT_TEXT: &str = "# See examples bellow for more!
    mov %r0, 10
@start
    cmp %r0, 0
    sub %r0, 1
    call [print]
    jmne [start]
    halt

@print
    add %sc, 7
    not %fa0
    test %fa0, 1
    movb [%sc; -6], 45
    movb [%sc; -5], 32
    movb [%sc; -4], 102
    movb [%sc; -3], 111
    movb [%sc; -2], 120
    jmne [:0] # FALSE
        movb [%sc; -1], 33
        jmp [:1]
    @:0
        movb [%sc; -1], 63
    @:1
    movb [%sc; 0], 10
    sub %sc, 6
    write %sc, 7
    ret
";

fn main() {
    dioxus_web::launch(App);
}

// Execute code, returns (messages, output)
fn exec_code(code: String) -> (String, String, Vec<u8>) {
    let mut msg = String::new();
    let start = window()
        .expect("window")
        .performance()
        .expect("performance")
        .now();

    let bytecode = {
        let tokens: Vec<_> = match Lex::new(code.as_str()).collect() {
            Ok(v) => v,
            Err(e) => {
                let fragment = &code[e.start.max(10) - 10..e.end.min(code.len() - 10) + 10];

                return (
                    format!("error:{}:{}: {}\n{fragment}", e.start, e.end, e.kind),
                    String::new(),
                    vec![]
                );
            }
        };
        let tree = match SyntaxTree::new(tokens.iter()) {
            Ok(v) => v.0,
            Err(e) => {
                let tokens = &tokens[e.idx.max(1) - 1..e.idx.min(tokens.len() - 6) + 6];

                return (
                    format!("error:@{}: {}\n{tokens:?}", e.idx, e.kind),
                    String::new(),
                    vec![]
                );
            }
        };
        let builtin = VMInfoBuilder::from_vm_opcodes::<FWMInfo>().to_syntax_items();
        let ctx = writer::Context::new()
            .populate(builtin.iter())
            .populate(tree.iter());

        match ctx.generate(tree.iter()) {
            Ok(v) => v,
            Err(e) => {
                return (format!("error:{}: {}", e.expr_id, e.kind), String::new(), vec![]);
            }
        }
    };

    let start = {
        let end = window()
            .expect("window")
            .performance()
            .expect("performance")
            .now();

        msg.push_str(&format!("Generated bytecode in {} ms\n", end - start));

        end
    };

    let opcodes = {
        let exprs: Result<Option<Vec<_>>, _> = parser::Parser::new(&bytecode)
            .into_iter()
            .map(|f| f.map(|r| OPCodeKind::from_raw(r.opcode).and_then(|o| o.to_opcode(&r.args))))
            .collect();

        match exprs {
            Ok(Some(v)) => v,
            Ok(None) => {
                return (
                    format!("vm-error: unknown opcode kind or syntax"),
                    String::new(),
                    bytecode
                );
            }
            Err(e) => {
                return (format!("vm-error: {e}"), String::new(), bytecode);
            }
        }
    };

    let mut fwm = FWMRunner::new(opcodes);
    let mut out = String::new();
    // limit
    for _ in 0..25_000 {
        match fwm.run() {
            FWMSignal::Continue => continue,
            FWMSignal::EOF => break,
            FWMSignal::Signaled => {
                return (
                    format!("signaled at expression #{}", fwm.context.get_local().pos),
                    out,
                    bytecode
                );
            }
            FWMSignal::Data(what) => {
                out.push_str(&String::from_utf8_lossy(what));
            }
        }
    }

    let end = window()
        .expect("window")
        .performance()
        .expect("performance")
        .now();
    msg.push_str(&format!("Executed in {} ms", end - start));
    (msg, out, bytecode)
}

fn App(cx: Scope) -> Element {
    let messages = use_state(cx, String::new);
    let output = use_state(cx, String::new);

    cx.render(rsx! {
        Inputbox {
            default_text: DEFAULT_TEXT,
            lang: "fwm playground, v0.1.0",
            on_change: |e: String| {
                let (msg, out, _bytecode) = exec_code(e);
                messages.set(msg);
                output.set(out);
            },
        },
        div {
            class: "split",
            div {
                Codebox {
                    lang: "messages",
                    "{messages}",
                },
            },
            div {
                Codebox {
                    lang: "output",
                    "{output}",
                },
            },
        }
    })
}
